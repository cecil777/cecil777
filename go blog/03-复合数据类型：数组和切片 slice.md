## 数组

数组有两个特点：
1. 固定长度
2. 元素类型相同

正是因为其长度固定，所以相比于切片，在开发过程中用的是比较少的。但数组是切片的基础，理解了数组，再学习切片就容易多了。

### 声明和初始化

声明一个长度是 3，元素类型是 ```int``` 的数组。通过索引来访问数组元素，索引从 0 到数组长度减 1，内置函数 ```len``` 可以获取数组长度。

``` go
var a [3]int
// 输出数组第一个元素
fmt.Println(a[0]) // 0
// 输出数组长度
fmt.Println(len(a)) // 3
```

数组初始值为元素类型零值，也可以用数组字面量初始化数组。

``` go
// 数组字面量初始化
var b [3]int = [3]int{1, 2, 3}
var c [3]int = [3]int{1, 2}
fmt.Println(b)    // [1 2 3]
fmt.Println(c[2]) // 0
```

如果没有显示指定数组长度，而是用 ```...```，那么数组长度由实际的元素数量决定。

``` go
// 使用 ...
d := [...]int{1, 2, 3, 4, 5}
fmt.Printf("%T\n", d) // [5]int
```

还可以指定索引位置来初始化，如果没有指定数组长度，则长度由索引来决定。

``` go
// 指定索引位置初始化
e := [4]int{5, 2: 10}
f := [...]int{2, 4: 6}
fmt.Println(e) // [5 0 10 0]
fmt.Println(f) // [2 0 0 0 6]
```

### 多维数组

多维数组的声明和初始化同理，这里以二维数组来举例说明，有一点需要注意，多维数组仅第一维允许使用 ```...```。

``` go
// 二维数组
var g [4][2]int
h := [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
// 声明并初始化外层数组中索引为 1 和 3 的元素
i := [4][2]int{1: {20, 21}, 3: {40, 41}}
// 声明并初始化外层数组和内层数组的单个元素
j := [...][2]int{1: {0: 20}, 3: {1: 41}}
fmt.Println(g, h, i, j)
```

### 使用数组

只要数组元素是可比较的，那么数组就是可比较的，而且数组长度也是数组类型的一部分。

所以 [3]int 和 [4]int 是两种不同的类型。

``` go
// 数组比较
a1 := [2]int{1, 2}
a2 := [...]int{1, 2}
a3 := [2]int{1, 3}
// a4 := [3]int{1, 2}
fmt.Println(a1 == a2, a1 == a3, a2 == a3) // true false false
// fmt.Println(a1 == a4)                     // invalid operation: a1 == a4 (mismatched types [2]int and [3]int)
```

数据遍历

``` go
// 数组遍历
for i, n := range e {
	fmt.Println(i, n)
}
```

### 值类型

Go 数组是值类型，赋值和传参都会复制整个数组。

从输出结果可以看出来，内容都是相同的，但地址不同。

``` go
package main

import "fmt"

func main() {
	// 数组复制
	x := [2]int{10, 20}
	y := x
	fmt.Printf("x: %p, %v\n", &x, x) // x: 0xc00012e020, [10 20]
	fmt.Printf("y: %p, %v\n", &y, y) // y: 0xc00012e030, [10 20]
	test(x)
}

func test(a [2]int) {
	fmt.Printf("a: %p, %v\n", &a, a) // a: 0xc00012e060, [10 20]
}
```

再来看看函数传参的情况：

``` go
package main

import "fmt"

func main() {
	x := [2]int{10, 20}

	// 传参
	modify(x)
	fmt.Println("main: ", x) // main:  [10 20]
}

func modify(a [2]int) {
	a[0] = 30
	fmt.Println("modify: ", a) // modify:  [30 20]
}
```

同样从结果可以看到，```modify``` 中数组内容修改后，```main``` 中数组内容并没有变化。

那么，有没有可能在函数内修改，而影响到函数外呢？答案是可以的，接下来要说的切片就可以做到。

## 切片 slice

切片是一种引用类型，它有三个属性：指针，长度和容量。

1. 指针：指向 slice 可以访问到的第一个元素。
2. 长度：slice 中元素个数。
3. 容量：slice 起始元素到底层数组最后一个元素间的元素个数。

看到这样的解释是不是一脸懵呢？别慌，咱们来详细解释一下。

它的底层结构是这样的：

![](https://gitee.com/cjh777/blog_pic/raw/672d0085c725d6a983423f05526a04809e6222d8/slice_pic/slice1.png)

































